<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Dashboard Interactivo – CSV Explorer</title>

  <!-- Tailwind CSS (CDN) -->
  <script src="https://cdn.tailwindcss.com"></script>

  <!-- Plotly.js (CDN) -->
  <script src="https://cdn.plot.ly/plotly-2.35.2.min.js"></script>

  <!-- PapaParse for CSV parsing -->
  <script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>

  <!-- DataTables (for table preview) -->
  <link rel="stylesheet" href="https://cdn.datatables.net/1.13.6/css/jquery.dataTables.min.css">
  <script src="https://code.jquery.com/jquery-3.7.1.min.js"></script>
  <script src="https://cdn.datatables.net/1.13.6/js/jquery.dataTables.min.js"></script>

  <style>
    /* Soft card look */
    .card { @apply bg-white rounded-2xl shadow p-5; }
    .label { @apply text-sm font-medium text-gray-600; }
    .value { @apply text-lg font-semibold text-gray-900; }
    .chip { @apply inline-flex items-center px-2.5 py-1 rounded-full bg-gray-100 text-gray-700 text-xs font-medium;}
    .section-title { @apply text-xl font-semibold text-gray-900; }
    .hint { @apply text-xs text-gray-500; }
  </style>
</head>
<body class="bg-gray-50 text-gray-800">
  <header class="max-w-7xl mx-auto px-4 py-6">
    <h1 class="text-2xl sm:text-3xl font-bold">Dashboard Interactivo – Explorador de CSV</h1>
    <p class="text-gray-600 mt-1">Listo para GitHub Pages. Carga un CSV desde URL o sube un archivo. Configura gráficos en vivo.</p>
  </header>

  <main class="max-w-7xl mx-auto px-4 pb-12 space-y-8">
    <!-- Data Loader -->
    <section class="card">
      <h2 class="section-title mb-4">1) Carga de Datos</h2>
      <div class="grid grid-cols-1 lg:grid-cols-12 gap-4 items-end">
        <div class="lg:col-span-7">
          <label class="label">URL del CSV</label>
          <input id="csvUrl" type="url" class="w-full mt-1 rounded-xl border-gray-300 focus:border-black focus:ring-0"
                 placeholder="https://..." value="https://raw.githubusercontent.com/carcin0gen/vt_extempo.ipynb/refs/heads/main/ecommerce_dataset_examen.csv" />
          <p class="hint mt-1">Usa un enlace directo al archivo .csv (por ejemplo, GitHub raw).</p>
        </div>
        <div class="lg:col-span-2">
          <button id="loadUrlBtn" class="w-full rounded-2xl bg-black text-white px-4 py-2 font-medium">Cargar URL</button>
        </div>
        <div class="lg:col-span-3">
          <label class="label">…o sube un CSV</label>
          <input id="fileInput" type="file" accept=".csv" class="w-full mt-1" />
        </div>
      </div>
      <p id="loadStatus" class="text-sm text-gray-600 mt-3"></p>
    </section>

    <!-- Overview / Summary -->
    <section class="card">
      <h2 class="section-title mb-4">2) Resumen</h2>
      <div class="grid grid-cols-2 sm:grid-cols-4 gap-4">
        <div class="bg-gray-50 rounded-xl p-4">
          <div class="label">Filas</div>
          <div id="rowsCount" class="value">–</div>
        </div>
        <div class="bg-gray-50 rounded-xl p-4">
          <div class="label">Columnas</div>
          <div id="colsCount" class="value">–</div>
        </div>
        <div class="bg-gray-50 rounded-xl p-4">
          <div class="label">Numéricas</div>
          <div id="numCols" class="value">–</div>
        </div>
        <div class="bg-gray-50 rounded-xl p-4">
          <div class="label">Categóricas</div>
          <div id="catCols" class="value">–</div>
        </div>
      </div>
      <div class="mt-4">
        <span class="chip">Detección automática de tipos</span>
        <span class="chip">Filtros dinámicos</span>
        <span class="chip">Gráficos interactivos</span>
      </div>
    </section>

    <!-- Filters -->
    <section class="card">
      <h2 class="section-title mb-4">3) Filtros</h2>
      <div class="grid grid-cols-1 md:grid-cols-4 gap-4">
        <div>
          <label class="label">Columna filtro 1 (categórica)</label>
          <select id="filterCol1" class="w-full mt-1 rounded-xl border-gray-300 focus:ring-0"></select>
          <select id="filterVal1" multiple class="w-full mt-2 rounded-xl border-gray-300 focus:ring-0"></select>
          <p class="hint">Mantén Ctrl/Cmd para seleccionar múltiples valores.</p>
        </div>
        <div>
          <label class="label">Columna filtro 2 (categórica)</label>
          <select id="filterCol2" class="w-full mt-1 rounded-xl border-gray-300 focus:ring-0"></select>
          <select id="filterVal2" multiple class="w-full mt-2 rounded-xl border-gray-300 focus:ring-0"></select>
        </div>
        <div>
          <label class="label">Columna fecha (opcional)</label>
          <select id="dateCol" class="w-full mt-1 rounded-xl border-gray-300 focus:ring-0"></select>
          <div class="grid grid-cols-2 gap-2 mt-2">
            <input id="dateFrom" type="date" class="rounded-xl border-gray-300 focus:ring-0" />
            <input id="dateTo" type="date" class="rounded-xl border-gray-300 focus:ring-0" />
          </div>
        </div>
        <div class="flex items-end">
          <button id="applyFilters" class="w-full rounded-2xl bg-black text-white px-4 py-2 font-medium">Aplicar filtros</button>
        </div>
      </div>
    </section>

    <!-- Chart Controls -->
    <section class="card">
      <h2 class="section-title mb-4">4) Configuración de Gráficos</h2>
      <div class="grid grid-cols-1 md:grid-cols-3 gap-4">
        <div>
          <label class="label">Numérica para Histograma</label>
          <select id="histNum" class="w-full mt-1 rounded-xl border-gray-300 focus:ring-0"></select>
        </div>
        <div>
          <label class="label">Categórica para Barras</label>
          <select id="barCat" class="w-full mt-1 rounded-xl border-gray-300 focus:ring-0"></select>
          <label class="label mt-2">Agregación</label>
          <select id="barAgg" class="w-full mt-1 rounded-xl border-gray-300 focus:ring-0">
            <option value="count">Conteo</option>
            <option value="sum">Suma</option>
            <option value="mean">Promedio</option>
            <option value="median">Mediana</option>
          </select>
          <label class="label mt-2">Sobre (col. numérica)</label>
          <select id="barNum" class="w-full mt-1 rounded-xl border-gray-300 focus:ring-0"></select>
        </div>
        <div>
          <label class="label">Dispersión: X (num.)</label>
          <select id="scatX" class="w-full mt-1 rounded-xl border-gray-300 focus:ring-0"></select>
          <label class="label mt-2">Dispersión: Y (num.)</label>
          <select id="scatY" class="w-full mt-1 rounded-xl border-gray-300 focus:ring-0"></select>
          <label class="label mt-2">Color (categ.)</label>
          <select id="scatColor" class="w-full mt-1 rounded-xl border-gray-300 focus:ring-0"></select>
        </div>
      </div>
      <div class="mt-4 flex gap-3">
        <button id="drawCharts" class="rounded-2xl bg-black text-white px-4 py-2 font-medium">Actualizar gráficos</button>
        <span class="hint">Primero carga datos; luego configura columnas para cada gráfico.</span>
      </div>
    </section>

    <!-- Charts -->
    <section class="grid grid-cols-1 lg:grid-cols-2 gap-6">
      <div class="card">
        <h3 class="font-semibold mb-2">Histograma</h3>
        <div id="histogram" class="w-full h-[360px]"></div>
        <p class="hint mt-2">Distribución de una variable numérica.</p>
      </div>
      <div class="card">
        <h3 class="font-semibold mb-2">Barras por Categoría</h3>
        <div id="bar" class="w-full h-[360px]"></div>
        <p class="hint mt-2">Comparación por categorías con agregación seleccionada.</p>
      </div>
      <div class="card lg:col-span-2">
        <h3 class="font-semibold mb-2">Dispersión</h3>
        <div id="scatter" class="w-full h-[420px]"></div>
        <p class="hint mt-2">Relación entre dos variables numéricas; color por categoría.</p>
      </div>
      <div class="card lg:col-span-2">
        <h3 class="font-semibold mb-2">Serie de Tiempo (si hay fecha)</h3>
        <div id="timeseries" class="w-full h-[420px]"></div>
        <p class="hint mt-2">Agregación diaria de una columna numérica sobre una columna de fecha.</p>
        <div class="grid grid-cols-1 md:grid-cols-3 gap-4 mt-3">
          <div>
            <label class="label">Columna numérica (serie)</label>
            <select id="tsNum" class="w-full mt-1 rounded-xl border-gray-300 focus:ring-0"></select>
          </div>
          <div>
            <label class="label">Agregación</label>
            <select id="tsAgg" class="w-full mt-1 rounded-xl border-gray-300 focus:ring-0">
              <option value="sum">Suma</option>
              <option value="mean">Promedio</option>
              <option value="median">Mediana</option>
              <option value="count">Conteo</option>
            </select>
          </div>
          <div class="flex items-end">
            <button id="drawTs" class="w-full rounded-2xl bg-black text-white px-4 py-2 font-medium">Actualizar serie</button>
          </div>
        </div>
      </div>
    </section>

    <!-- Data preview table -->
    <section class="card">
      <h2 class="section-title mb-4">5) Vista previa de datos</h2>
      <div class="overflow-x-auto">
        <table id="dataTable" class="display" style="width:100%"></table>
      </div>
    </section>

    <!-- Footer -->
    <footer class="text-center text-xs text-gray-500">
      <p class="mt-6">Hecho con ❤️ • Funciona 100% en GitHub Pages (sin backend)</p>
    </footer>
  </main>

  <script>
    // --- Global state ---
    let rawData = [];   // Array of row objects
    let columns = [];   // All column names
    let numCols = [];   // Numeric columns
    let catCols = [];   // Categorical columns
    let dateCols = [];  // Date-like columns
    let filtered = [];  // Filtered data

    // --- Helpers ---
    function isNumeric(val) {
      if (val === null || val === undefined) return false;
      if (val === '') return false;
      const n = Number(val);
      return !isNaN(n) && isFinite(n);
    }

    function looksLikeDate(s) {
      if (s === null || s === undefined || s === '') return false;
      const d = new Date(s);
      return !isNaN(d.getTime());
    }

    function detectTypes(sampleRows, cols) {
      const numeric = [];
      const categoric = [];
      const dateLike = [];

      cols.forEach(col => {
        // Check first ~50 non-empty values
        let nCount = 0, dCount = 0, total = 0;
        for (let r of sampleRows) {
          const v = r[col];
          if (v !== undefined && v !== null && String(v).trim() !== '') {
            total++;
            if (isNumeric(v)) nCount++;
            if (looksLikeDate(v)) dCount++;
            if (total >= 50) break;
          }
        }
        // Heuristics
        if (nCount > 0 && nCount / Math.max(1,total) > 0.7) {
          numeric.push(col);
        } else if (dCount > 0 && dCount / Math.max(1,total) > 0.7) {
          dateLike.push(col);
        } else {
          categoric.push(col);
        }
      });
      return { numeric, categoric, dateLike };
    }

    function uniqueValues(arr, key) {
      const set = new Set(arr.map(r => r[key]).filter(v => v !== undefined && v !== null && String(v).trim() !== ''));
      return Array.from(set).sort((a,b) => String(a).localeCompare(String(b)));
    }

    function applyCurrentFilters() {
      const fc1 = document.getElementById('filterCol1').value;
      const fc2 = document.getElementById('filterCol2').value;
      const vals1 = Array.from(document.getElementById('filterVal1').selectedOptions).map(o => o.value);
      const vals2 = Array.from(document.getElementById('filterVal2').selectedOptions).map(o => o.value);
      const dcol = document.getElementById('dateCol').value;
      const dfrom = document.getElementById('dateFrom').value;
      const dto = document.getElementById('dateTo').value;

      filtered = rawData.filter(row => {
        let ok = true;
        if (fc1 && vals1.length) ok = ok && vals1.includes(String(row[fc1]));
        if (fc2 && vals2.length) ok = ok && vals2.includes(String(row[fc2]));
        if (dcol) {
          const dateVal = new Date(row[dcol]);
          if (dfrom) ok = ok && dateVal >= new Date(dfrom);
          if (dto) ok = ok && dateVal <= new Date(dto);
        }
        return ok;
      });
      return filtered;
    }

    function populateSelect(selectId, items, placeholder='') {
      const sel = document.getElementById(selectId);
      sel.innerHTML = '';
      if (placeholder) {
        const opt = document.createElement('option');
        opt.value = '';
        opt.textContent = placeholder;
        sel.appendChild(opt);
      }
      items.forEach(it => {
        const opt = document.createElement('option');
        opt.value = it;
        opt.textContent = it;
        sel.appendChild(opt);
      });
    }

    function populateMulti(selectId, items) {
      const sel = document.getElementById(selectId);
      sel.innerHTML = '';
      items.forEach(it => {
        const opt = document.createElement('option');
        opt.value = it;
        opt.textContent = it;
        sel.appendChild(opt);
      });
    }

    function updateSummary() {
      document.getElementById('rowsCount').textContent = rawData.length.toLocaleString();
      document.getElementById('colsCount').textContent = columns.length;
      document.getElementById('numCols').textContent = numCols.length;
      document.getElementById('catCols').textContent = catCols.length;
    }

    function refreshFilterChoices() {
      // Filter columns can only be categorical
      populateSelect('filterCol1', [''].concat(catCols), '');
      populateSelect('filterCol2', [''].concat(catCols), '');
      populateSelect('dateCol', [''].concat(dateCols), '');
      // When a filter column is chosen, we populate its values
      const onChange = (colSelId, valSelId) => {
        document.getElementById(colSelId).addEventListener('change', e => {
          const col = e.target.value;
          if (col) {
            populateMulti(valSelId, uniqueValues(rawData, col));
          } else {
            populateMulti(valSelId, []);
          }
        });
      };
      onChange('filterCol1', 'filterVal1');
      onChange('filterCol2', 'filterVal2');
    }

    function refreshChartChoices() {
      populateSelect('histNum', numCols, '');
      populateSelect('barCat', catCols, '');
      populateSelect('barNum', [''].concat(numCols), '');
      populateSelect('scatX', numCols, '');
      populateSelect('scatY', numCols, '');
      populateSelect('scatColor', [''].concat(catCols), '');
      populateSelect('tsNum', [''].concat(numCols), '');
    }

    function drawHistogram(data, col) {
      const values = data.map(r => Number(r[col])).filter(v => !isNaN(v));
      const trace = { x: values, type: 'histogram', nbinsx: 30, hovertemplate: '%{x}<br>Frecuencia: %{y}<extra></extra>' };
      const layout = { margin: {l: 40, r: 10, t: 10, b: 40}, xaxis: {title: col}, yaxis: {title: 'Frecuencia'} };
      Plotly.newPlot('histogram', [trace], layout, {responsive: true});
    }

    function aggregate(values, method) {
      if (method === 'count') return values.length;
      if (!values.length) return null;
      if (method === 'sum') return values.reduce((a,b) => a + b, 0);
      if (method === 'mean') return values.reduce((a,b) => a + b, 0) / values.length;
      if (method === 'median') {
        const sorted = [...values].sort((a,b)=>a-b);
        const mid = Math.floor(sorted.length/2);
        return sorted.length % 2 ? sorted[mid] : (sorted[mid-1]+sorted[mid])/2;
      }
      return null;
    }

    function drawBar(data, catCol, aggMethod, numCol) {
      const map = new Map();
      data.forEach(r => {
        const key = String(r[catCol]);
        const val = numCol ? Number(r[numCol]) : 1;
        if (!map.has(key)) map.set(key, []);
        if (aggMethod === 'count') {
          map.get(key).push(1);
        } else if (!isNaN(val)) {
          map.get(key).push(val);
        }
      });
      const cats = Array.from(map.keys());
      const vals = cats.map(c => aggregate(map.get(c), aggMethod) ?? 0);
      const trace = { x: cats, y: vals, type: 'bar', hovertemplate: '%{x}<br>Valor: %{y}<extra></extra>' };
      const layout = { margin: {l: 40, r: 10, t: 10, b: 80}, xaxis: {title: catCol, tickangle: -30}, yaxis: {title: aggMethod} };
      Plotly.newPlot('bar', [trace], layout, {responsive: true});
    }

    function drawScatter(data, xCol, yCol, colorCol) {
      if (!xCol || !yCol) {
        Plotly.purge('scatter');
        return;
      }
      if (colorCol) {
        const groups = new Map();
        data.forEach(r => {
          const x = Number(r[xCol]);
          const y = Number(r[yCol]);
          if (isNaN(x) || isNaN(y)) return;
          const key = String(r[colorCol]);
          if (!groups.has(key)) groups.set(key, {x:[], y:[], text:[]});
          groups.get(key).x.push(x);
          groups.get(key).y.push(y);
          groups.get(key).text.push(key);
        });
        const traces = Array.from(groups.keys()).map(k => ({
          x: groups.get(k).x, y: groups.get(k).y, mode: 'markers', type: 'scattergl', name: k,
          hovertemplate: `${xCol}: %{x}<br>${yCol}: %{y}<extra>${k}</extra>`
        }));
        Plotly.newPlot('scatter', traces, {
          margin: {l: 50, r: 10, t: 10, b: 40},
          xaxis: {title: xCol},
          yaxis: {title: yCol},
          legend: {orientation: 'h'}
        }, {responsive:true});
      } else {
        const x = [], y = [];
        data.forEach(r => {
          const xv = Number(r[xCol]);
          const yv = Number(r[yCol]);
          if (!isNaN(xv) && !isNaN(yv)) { x.push(xv); y.push(yv); }
        });
        const trace = { x, y, mode: 'markers', type: 'scattergl', hovertemplate: `${xCol}: %{x}<br>${yCol}: %{y}<extra></extra>` };
        Plotly.newPlot('scatter', [trace], { margin: {l: 50,r: 10,t: 10,b: 40}, xaxis:{title:xCol}, yaxis:{title:yCol} }, {responsive:true});
      }
    }

    function drawTimeSeries(data, dateCol, numCol, aggMethod) {
      if (!dateCol || !numCol) {
        Plotly.purge('timeseries');
        return;
      }
      // Group by day
      const buckets = new Map();
      data.forEach(r => {
        const d = new Date(r[dateCol]);
        if (isNaN(d.getTime())) return;
        const key = d.toISOString().slice(0,10); // YYYY-MM-DD
        const val = Number(r[numCol]);
        if (!buckets.has(key)) buckets.set(key, []);
        if (aggMethod === 'count') {
          buckets.get(key).push(1);
        } else if (!isNaN(val)) {
          buckets.get(key).push(val);
        }
      });
      const dates = Array.from(buckets.keys()).sort();
      const vals = dates.map(k => aggregate(buckets.get(k), aggMethod) ?? 0);
      const trace = { x: dates, y: vals, type: 'scatter', mode: 'lines+markers', hovertemplate: '%{x}<br>Valor: %{y}<extra></extra>' };
      const layout = { margin: {l: 50,r:10,t:10,b:40}, xaxis:{title: dateCol}, yaxis:{title: `${aggMethod} de ${numCol}`} };
      Plotly.newPlot('timeseries', [trace], layout, {responsive: true});
    }

    // Table preview with DataTables
    let dataTableInstance = null;
    function renderTable(data) {
      const table = $('#dataTable');
      if (dataTableInstance) {
        dataTableInstance.destroy();
        table.empty();
      }
      if (!data.length) return;
      const cols = Object.keys(data[0]).map(c => ({ title: c, data: c }));
      dataTableInstance = table.DataTable({
        data: data,
        columns: cols,
        pageLength: 10,
        deferRender: true,
        scrollX: true
      });
    }

    // --- Loaders ---
    function loadFromUrl() {
      const url = document.getElementById('csvUrl').value.trim();
      if (!url) return;
      document.getElementById('loadStatus').textContent = 'Descargando y parseando CSV…';
      Papa.parse(url, {
        download: true,
        header: true,
        skipEmptyLines: true,
        complete: (results) => {
          onDataLoaded(results.data);
        },
        error: (err) => {
          document.getElementById('loadStatus').textContent = 'Error al cargar CSV: ' + err;
        }
      });
    }

    function loadFromFile(file) {
      document.getElementById('loadStatus').textContent = 'Leyendo archivo…';
      Papa.parse(file, {
        header: true,
        skipEmptyLines: true,
        complete: (results) => {
          onDataLoaded(results.data);
        },
        error: (err) => {
          document.getElementById('loadStatus').textContent = 'Error al leer archivo: ' + err;
        }
      });
    }

    function onDataLoaded(data) {
      rawData = data;
      filtered = data;
      columns = rawData.length ? Object.keys(rawData[0]) : [];

      const { numeric, categoric, dateLike } = detectTypes(rawData, columns);
      numCols = numeric;
      catCols = categoric;
      dateCols = dateLike;
      updateSummary();
      refreshFilterChoices();
      refreshChartChoices();

      // If there is a likely date column, preselect for filters
      if (dateCols.length) {
        document.getElementById('dateCol').value = dateCols[0];
      }
      // Draw default charts if possible
      if (numCols.length) {
        document.getElementById('histNum').value = numCols[0];
        drawHistogram(filtered, numCols[0]);
      } else {
        Plotly.purge('histogram');
      }

      if (catCols.length) {
        document.getElementById('barCat').value = catCols[0];
        drawBar(filtered, catCols[0], document.getElementById('barAgg').value, document.getElementById('barNum').value || null);
      } else {
        Plotly.purge('bar');
      }

      if (numCols.length >=2) {
        document.getElementById('scatX').value = numCols[0];
        document.getElementById('scatY').value = numCols[1];
        drawScatter(filtered, numCols[0], numCols[1], document.getElementById('scatColor').value || null);
      } else {
        Plotly.purge('scatter');
      }

      renderTable(filtered.slice(0, 1000)); // preview first 1000 rows to keep it fast
      document.getElementById('loadStatus').textContent = 'Datos listos ✔️';
    }

    // --- Event bindings ---
    document.getElementById('loadUrlBtn').addEventListener('click', loadFromUrl);
    document.getElementById('fileInput').addEventListener('change', e => {
      if (e.target.files && e.target.files.length) loadFromFile(e.target.files[0]);
    });
    document.getElementById('applyFilters').addEventListener('click', () => {
      applyCurrentFilters();
      // Redraw charts with filtered subset
      const h = document.getElementById('histNum').value;
      const c = document.getElementById('barCat').value;
      const agg = document.getElementById('barAgg').value;
      const bn = document.getElementById('barNum').value || null;
      const sx = document.getElementById('scatX').value;
      const sy = document.getElementById('scatY').value;
      const sc = document.getElementById('scatColor').value || null;
      const dcol = document.getElementById('dateCol').value;
      const tsn = document.getElementById('tsNum').value || null;
      const tsa = document.getElementById('tsAgg').value;

      if (h) drawHistogram(filtered, h); else Plotly.purge('histogram');
      if (c) drawBar(filtered, c, agg, bn); else Plotly.purge('bar');
      if (sx && sy) drawScatter(filtered, sx, sy, sc); else Plotly.purge('scatter');
      if (dcol && tsn) drawTimeSeries(filtered, dcol, tsn, tsa); else Plotly.purge('timeseries');

      renderTable(filtered.slice(0, 1000));
    });

    document.getElementById('drawCharts').addEventListener('click', () => {
      const h = document.getElementById('histNum').value;
      const c = document.getElementById('barCat').value;
      const agg = document.getElementById('barAgg').value;
      const bn = document.getElementById('barNum').value || null;
      const sx = document.getElementById('scatX').value;
      const sy = document.getElementById('scatY').value;
      const sc = document.getElementById('scatColor').value || null;

      if (h) drawHistogram(filtered, h); else Plotly.purge('histogram');
      if (c) drawBar(filtered, c, agg, bn); else Plotly.purge('bar');
      if (sx && sy) drawScatter(filtered, sx, sy, sc); else Plotly.purge('scatter');
    });

    document.getElementById('drawTs').addEventListener('click', () => {
      const dcol = document.getElementById('dateCol').value;
      const tsn = document.getElementById('tsNum').value || null;
      const tsa = document.getElementById('tsAgg').value;
      if (dcol && tsn) drawTimeSeries(filtered, dcol, tsn, tsa);
    });

    // Auto-load the default URL on first open for convenience
    window.addEventListener('load', () => {
      loadFromUrl();
    });
  </script>
</body>
</html>
